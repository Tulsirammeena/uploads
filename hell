// Handle buy/sell actions
window.handleAction = async function(action, symbol) {
    const quantity = prompt("Enter the quantity:");
    if (!quantity || isNaN(quantity)) {
        alert("Invalid quantity!");
        return;
    }

    const orderData = {
        stockSymbol: symbol,
        action: action.toUpperCase(),
        quantity: parseInt(quantity)
    };

    try {
        const response = await fetch('http://localhost:8081/api/orders/create', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(orderData)
        });

        if (response.ok) {
            alert("Order placed successfully!");
        } else {
            alert("Failed to place order.");
        }
    } catch (error) {
        console.error('Error placing order:', error);
    }
};


@RestController
@RequestMapping("/api/orders")
public class OrderController {

    @Autowired
    private OrderService orderService;

    @PostMapping("/create")
    public ResponseEntity<String> createOrder(@RequestBody OrderRequest orderRequest) {
        try {
            orderService.createOrder(orderRequest);
            return ResponseEntity.ok("Order placed successfully!");
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error creating order: " + e.getMessage());
        }
    }
}



public class OrderModel {
	private Integer orderId;
    public String OrderType; // Equivalent to OrderType
    private String companyName; // Requires a lookup or join to get the company name
    private LocalDateTime date;
    private BigDecimal price;
    private Integer quantity;
    private BigDecimal totalPrice;
    public String status; // Equivalent to OrderStatus
    
    
    
    public Integer getOrderId() {
        return orderId;
    }

    public void setTransactionId(Integer orderId) {
        this.orderId = orderId;
    }

    public String getOrderType() {
        return OrderType;
    }

    public void setTransactionType(String OrderType) {
        this.OrderType = OrderType;
    }

    public String getCompanyName() {
        return companyName;
    }

    public void setCompanyName(String companyName) {
        this.companyName = companyName;
    }

    public LocalDateTime getDate() {
        return date;
    }

    public void setDate(LocalDateTime date) {
        this.date = date;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setSharePrice(BigDecimal price) {
        this.price = price;
    }

    public Integer getQuantity() {
        return quantity;
    }

    public void setQuantity(Integer quantity) {
        this.quantity = quantity;
    }

    public BigDecimal getTotalPrice() {
        return totalPrice;
    }

    public void setTotalPrice(BigDecimal totalPrice) {
        this.totalPrice = totalPrice;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }
}


@Repository
public interface OrderRepo extends JpaRepository<OrderEntity, Integer> {

//	List<OrderEntity> findByTimeRange(LocalDateTime startOfDay, LocalDateTime endOfDay);

//	List<OrderEntity> findByTimeStampBetweenAndStatus(LocalDateTime startOfDay, LocalDateTime endOfDay,String status);

//	List<OrderEntity> findByCreatedAtBetweenAndStatus(LocalDateTime startOfDay, LocalDateTime endOfDay, String string);

	//List<OrderEntity> findByStockDetail_StockId(String string);

	List<OrderEntity> findByStockDetail_Symbol(String string);
	
//	List<OrderEntity> findByStockDetail_SymbolAndCreatedAtBetween(String string, LocalDateTime startOfDay, LocalDateTime endOfDay);

//	List<OrderEntity> findByStockDetail_SymbolAndStatusAndCreatedAtBetween(String string, LocalDateTime startOfDay,
//			LocalDateTime endOfDay, String string2);



	List<OrderEntity> findByStockDetail_SymbolAndCreatedAtBetweenAndStatus(String string, LocalDateTime startOfDay,
			LocalDateTime endOfDay, OrderStatus pending);

//	List<OrderEntity> findByCreatedAtBetweenAndStatusAndStockId(LocalDateTime startOfDay, LocalDateTime endOfDay,
//			String string, String name);	

}



@Service
public class OrderService {

    @Autowired
    private OrderRepo orderRepository;

 //   @Autowired
//    private CompanyRepository companyRepository; // Assuming you have this to get company names

    public List<OrderEntity> getAllOrders() {
        return orderRepository.findAll();
    }

    public List<OrderModel> getOrderHistory(String userName, LocalDateTime beginDate, LocalDateTime endDate) {
        List<OrderEntity> orders = orderRepository.findAll();

        if (userName != null) {
            orders = orders.stream()
                .filter(order -> order.getUser().getUserName().equals(userName))
                .collect(Collectors.toList());
        }

        if (beginDate != null && endDate != null) {
            orders = orders.stream()
                .filter(order -> !order.getCreatedAt().isBefore(beginDate) && !order.getCreatedAt().isAfter(endDate))
                .collect(Collectors.toList());
        }

        return orders.stream().map(order -> {
            OrderModel dto = new OrderModel();
            dto.setTransactionId(order.getOrderId());
            dto.setTransactionType(order.getOrderType().name());
//            dto.setCompanyName(getCompanyNameById(order.getCompanyId()));
            dto.setDate(order.getCreatedAt());
            dto.setCompanyName(order.getStockDetail().getName());
            dto.setSharePrice(order.getPrice());
            dto.setQuantity(order.getQuantity());
            dto.setTotalPrice(order.getPrice().multiply(BigDecimal.valueOf(order.getQuantity())));
            dto.setStatus(order.getStatus().name());
            return dto;
        }).collect(Collectors.toList());
    }

//    private String getCompanyNameById(Long companyId) {
//        // Fetch company name by companyId
//        Optional<Company> company = companyRepository.findById(companyId);
//        return company.map(Company::getName).orElse("Unknown");
//    }
}

@Entity
@Data
@Table(name = "order_history")
public class OrderEntity {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "order_seq")
	@SequenceGenerator(name = "order_seq", sequenceName = "order_seq", allocationSize = 1)
	private Integer orderId;

	@ManyToOne(optional = false)
	@JoinColumn(name = "user_id", referencedColumnName = "userName")
	private UserEntity user;

	@ManyToOne(optional = false)
	@JoinColumn(name = "stock_id", referencedColumnName = "symbol")
	private StockEntity stockDetail;

	@Enumerated(EnumType.STRING)
	@Column(name = "order_type", nullable = false)
	private OrderType orderType;

	@Column(name = "quantity", nullable = false)
	private Integer quantity;

	@Column(name = "price", nullable = false)
	private BigDecimal price;

	@Enumerated(EnumType.STRING)
	@Column(name = "status", nullable = false)
	private OrderStatus status;
	
	private LocalDateTime createdAt;
	
//	public OrderEntity(String stockId, String userId,Integer quantity, String orderType) {
//		
//	}
}


@Entity
@Data
@NoArgsConstructor
@Table(name = "user_info")
public class UserEntity {

	
//	@GeneratedValue(strategy = GenerationType.IDENTITY)
//	private Long userId;
	@Id
	private String userName;
	private String fullName;
	private String city;
	private String phoneNumber;
	private String password;
	private String emailAddress;
	private String role;
	private String panNo;
	private LocalDateTime createdAt;
//	private Long DAN;
	@OneToMany(mappedBy = "user", fetch = FetchType.LAZY,cascade = CascadeType.PERSIST,
			targetEntity = HoldingEntity.class)
	private Set<HoldingEntity> holdings;
	
	public UserEntity(UserModel user) {
		this.userName = user.getUserName();
		this.password = user.getPassword();
		this.fullName = user.getFullName();
		this.city=user.getCity();
		this.emailAddress = user.getEmailAddress();
		this.phoneNumber = user.getPhoneNumber();
		this.role = user.getRole();
		this.panNo = user.getPanNo();
		this.createdAt = LocalDateTime.now();
	}
}


@Entity
@NoArgsConstructor
@AllArgsConstructor	
@Data
@Table(name = "stock_info")
public class StockEntity {

//	@Id
//	@GeneratedValue(strategy = GenerationType.IDENTITY)
//	private Integer companyId;
	
	@Column(nullable = false, length = 100)
    private String name;
	
	@Id
    private String symbol;
	
	@Column(columnDefinition = "TEXT")
    private String description;
	
//	@OneToMany(mappedBy = "stock", fetch = FetchType.LAZY,cascade = CascadeType.PERSIST,
//			targetEntity = StockHistoryEntity.class)
//	private List<StockHistoryEntity> stockHistory;
    
//    @Override
//    public boolean equals(Object o) {
//        if (this == o) return true;
//        if (o == null || getClass() != o.getClass()) return false;
//        CompanyEntity company = (CompanyEntity) o;
//        return Objects.equals(companyId, company.companyId) &&
//               Objects.equals(name, company.name) &&
//               Objects.equals(symbol, company.symbol) &&
//               Objects.equals(description, company.description);
//    }
//
//    @Override
//    public int hashCode() {
//        return Objects.hash(companyId, name, symbol, description);
//    }
//    
    @Override
    public String toString() {
        return "Company{" +
               "name='" + name + '\'' +
               ", symbol='" + symbol + '\'' +
               ", description='" + description + '\'' +
               ""+
               '}';
    }
    
    
//   public StockEntity(StockModel stock) {
//	   this.name = stock.getName();
//	   this.symbol = stock.getSymbol();
//	   this.description = stock.getDescription();
//   }
	
}
