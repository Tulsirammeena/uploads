@Entity
@Data
@Table(name = "order_history")
public class OrderEntity {

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "order_seq")
	@SequenceGenerator(name = "order_seq", sequenceName = "order_seq", allocationSize = 1)
	private Integer orderId;

	@ManyToOne(optional = false)
	@JoinColumn(name = "user_id", referencedColumnName = "userName")
	private UserEntity user;

	@ManyToOne(optional = false)
	@JoinColumn(name = "stock_id", referencedColumnName = "symbol")
	private StockEntity stockDetail;

	@Enumerated(EnumType.STRING)
	@Column(name = "order_type", nullable = false)
	private OrderType orderType;

	@Column(name = "quantity", nullable = false)
	private Integer quantity;

	@Column(name = "price", nullable = false)
	private BigDecimal price;

	@Enumerated(EnumType.STRING)
	@Column(name = "status", nullable = false)
	private OrderStatus status;
	
	private LocalDateTime createdAt;
	
//	public OrderEntity(String stockId, String userId,Integer quantity, String orderType) {
//		
//	}
}



@Service
public class OrderService {

    @Autowired
    private OrderRepo orderRepository;


    @Autowired
    private StockRepo stockRepo;

    @Autowired
    private HoldingRepo holdingRepo;
 //   @Autowired
//    private CompanyRepository companyRepository; // Assuming you have this to get company names

    public List<OrderEntity> getAllOrders() {
        return orderRepository.findAll();
    }

    public List<OrderModel> getOrderHistory(String userName, LocalDateTime beginDate, LocalDateTime endDate) {
        List<OrderEntity> orders = orderRepository.findAll();

        if (userName != null) {
            orders = orders.stream()
                .filter(order -> order.getUser().getUserName().equals(userName))
                .collect(Collectors.toList());
        }

        if (beginDate != null && endDate != null) {
            orders = orders.stream()
                .filter(order -> !order.getCreatedAt().isBefore(beginDate) && !order.getCreatedAt().isAfter(endDate))
                .collect(Collectors.toList());
        }

        return orders.stream().map(order -> {
            OrderModel dto = new OrderModel();
            dto.setTransactionId(order.getOrderId());
            dto.setTransactionType(order.getOrderType().name());
//            dto.setCompanyName(getCompanyNameById(order.getCompanyId()));
            dto.setDate(order.getCreatedAt());
            dto.setCompanyName(order.getStockDetail().getName());
            dto.setSharePrice(order.getPrice());
            dto.setQuantity(order.getQuantity());
            dto.setTotalPrice(order.getPrice().multiply(BigDecimal.valueOf(order.getQuantity())));
            dto.setStatus(order.getStatus().name());
            return dto;
        }).collect(Collectors.toList());
    }
    
    public void createOrder(OrderModel orderModel) throws Exception {
        // Fetch stock details by symbol
        StockEntity stock = stockRepo.findById(orderModel.getCompanyName())
                .orElseThrow(() -> new Exception("Stock not found"));

        // Get the current logged-in user
        UserEntity user = getCurrentUser();  // Method to fetch the logged-in user

        // Create and populate the OrderEntity
        OrderEntity order = new OrderEntity();
        order.setStockDetail(stock);
        order.setUser(user);
        order.setQuantity(orderModel.getQuantity());
        order.setPrice(stock.getPrice());  // Use the current price from the stock
        order.setOrderType(OrderType.valueOf(orderModel.getOrderType()));
        order.setStatus(OrderStatus.PENDING);  // Initially, the order is pending
        order.setCreatedAt(LocalDateTime.now());

        // Validate holdings for Sell orders
        if (orderModel.getOrderType().equalsIgnoreCase("SELL")) {
            Optional<HoldingEntity> holding = holdingRepo.findByUser_UserNameAndStock_Symbol(user.getUserName(), stock.getSymbol());
            if (holding.isPresent() && holding.get().getNoOfStocks() >= orderModel.getQuantity()) {
                orderRepository.save(order);
            } else {
                throw new Exception("Not enough stocks to sell");
            }
        } else {
            // For BUY orders, directly save the order
            orderRepository.save(order);
        }
    }

	private UserEntity getCurrentUser() {
		// TODO Auto-generated method stub
		return null;
	}
}


//    private String getCompanyNameById(Long companyId) {
//        // Fetch company name by companyId
//        Optional<Company> company = companyRepository.findById(companyId);
//        return company.map(Company::getName).orElse("Unknown");
//    }



  // Fetches the current authenticated user from Spring Security
    private UserEntity getCurrentUser() {
        Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();

        if (principal instanceof UserDetails) {
            String username = ((UserDetails) principal).getUsername();
            return userRepo.findByUserName(username)
                    .orElseThrow(() -> new RuntimeException("User not found: " + username));
        } else {
            throw new RuntimeException("No authenticated user found");
        }
    }




public void createOrder(OrderModel orderModel, String userName) throws Exception {
        // Fetch stock details by symbol
        StockEntity stock = stockRepo.findById(orderModel.getCompanyName())
                .orElseThrow(() -> new Exception("Stock not found"));

        // Fetch the user by the passed userName from the frontend
        UserEntity user = userRepo.findByUserName(userName)
                .orElseThrow(() -> new Exception("User not found"));

        // Create and populate the OrderEntity
        OrderEntity order = new OrderEntity();
        order.setStockDetail(stock);
        order.setUser(user);
        order.setQuantity(orderModel.getQuantity());
        order.setPrice(stock.getPrice());  // Use the current price from the stock
        order.setOrderType(OrderType.valueOf(orderModel.getOrderType()));
        order.setStatus(OrderStatus.PENDING);  // Initially, the order is pending
        order.setCreatedAt(LocalDateTime.now());

        // Save order based on order type
        if (orderModel.getOrderType().equalsIgnoreCase("SELL")) {
            Optional<HoldingEntity> holding = holdingRepo.findByUser_UserNameAndStock_Symbol(user.getUserName(), stock.getSymbol());
            if (holding.isPresent() && holding.get().getNoOfStocks() >= orderModel.getQuantity()) {
                orderRepository.save(order);
            } else {
                throw new Exception("Not enough stocks to sell");
            }
        } else {
            // Save BUY orders directly
            orderRepository.save(order);
        }
    }



document.addEventListener('DOMContentLoaded', () => {
    // Function to fetch stock data from the API
    async function fetchStockData() {
        try {
            const response = await fetch('http://localhost:8081/stocks/list');
            const data = await response.json();

            if (data.statusCode === 200) {
                populateStocksTable(data.data);
            } else {
                console.error('Error fetching data:', data.message);
            }
        } catch (error) {
            console.error('Error:', error);
        }
    }

    // Function to populate the stocks table with fetched data
    function populateStocksTable(stocks) {
        const tableBody = document.querySelector('#stocksTableBody');
        tableBody.innerHTML = ''; // Clear existing data

        stocks.forEach(stock => {
            const row = document.createElement('tr');

            row.innerHTML = `
                <td>${stock.symbol}</td>
                <td>${stock.name}</td>
                <td>$${stock.price.toFixed(2)}</td>
                <td>${stock.volume.toLocaleString()}</td>
                <td>${stock.percentageChange.toLocaleString()}</td>

                <td><button class="buy-btn" onclick="handleAction('buy', '${stock.symbol}')">Buy</button>
                <button class="sell-btn" onclick="handleAction('sell', '${stock.symbol}')">Sell</button></td>
            `;

            tableBody.appendChild(row);
        });
    }

    // Function to handle Buy/Sell actions
    window.handleAction = async function(action, symbol) {
        // Prompt user for quantity
        const quantity = prompt("Enter the quantity:");
        if (!quantity || isNaN(quantity) || quantity <= 0) {
            alert("Please enter a valid quantity.");
            return;
        }
        
        // Get the current user's username (you might store this in session/localStorage or have a way to get it)
        const userName = getCurrentUserName(); // Implement this function based on how you manage user sessions

        // Check if userName exists
        if (!userName) {
            alert("User is not authenticated. Please log in.");
            return;
        }

        const orderData = {
            stockSymbol: symbol,
            action: action.toUpperCase(), // BUY or SELL
            quantity: parseInt(quantity),
            userName: userName  // Pass the username in the request
        };

        try {
            const response = await fetch('http://localhost:8081/api/orders/create', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(orderData)
            });

            if (response.ok) {
                alert("Order placed successfully!");
            } else {
                alert("Failed to place order.");
            }
        } catch (error) {
            console.error('Error placing order:', error);
        }
    };

    // Handle logout
    document.getElementById('logoutButton').addEventListener('click', () => {
        alert('Logging out...');
        // Implement logout logic here
        window.location.href = 'login.html';
    });

    // Fetch and display stock data when the page loads
    fetchStockData();
});

// Function to get the current user's username (you can adapt this as needed)
function getCurrentUserName() {
    // Example: Retrieve the username from localStorage or a global variable
    // Replace this logic with how you're storing the user's session
    return localStorage.getItem('userName');  // This assumes you store the username in localStorage
}
